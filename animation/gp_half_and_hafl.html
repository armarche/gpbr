<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GP Half-and-Half Tree Generation Animation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .visualization {
            width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        .sets-display {
            margin: 15px 0;
            padding: 15px;
            border-radius: 6px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
        }
        .node-set {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .set-label {
            font-weight: bold;
            width: 100px;
        }
        .node-item {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            margin: 0 5px;
            border-radius: 50%;
            background-color: white;
            border: 2px solid #3498db;
            transition: all 0.3s;
        }
        .function-node {
            border-color: #3498db;
            color: #3498db;
        }
        .terminal-node {
            border-color: #2ecc71;
            color: #2ecc71;
        }
        .selected {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            font-weight: bold;
        }
        .function-node.selected {
            background-color: #3498db;
            color: white;
        }
        .terminal-node.selected {
            background-color: #2ecc71;
            color: white;
        }
        canvas {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-top: 15px;
            display: block;
            margin: 15px auto 0;
        }
        .control-panel {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .speed-control {
            display: flex;
            align-items: center;
            margin-left: 20px;
        }
        #method-display {
            margin-left: 20px;
            font-weight: bold;
            color: #3498db;
        }
        .tooltip {
            background-color: #34495e;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            position: absolute;
            display: none;
        }
        .step-info {
            margin: 10px 0;
            padding: 10px;
            background: #eef7fa;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Genetic Programming: Half-and-Half Tree Generation</h1>
        
        <div class="control-panel">
            <button id="startBtn">Start Animation</button>
            <button id="pauseBtn">Pause</button>
            <button id="nextBtn">Next Step</button>
            <button id="resetBtn">Reset</button>
            
            <div class="speed-control">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" min="100" max="2000" value="1000">
            </div>
            
            <span id="method-display">Method: Grow</span>
        </div>
        
        <div class="visualization">
            <h2>Tree Construction Visualization</h2>
            
            <div class="sets-display">
                <div class="node-set">
                    <span class="set-label">Terminals:</span>
                    <div id="terminals-container"></div>
                </div>
                <div class="node-set">
                    <span class="set-label">Functions:</span>
                    <div id="functions-container"></div>
                </div>
                <div id="selection-info" style="margin-top:10px;font-weight:bold;"></div>
            </div>

            <div id="step-info" class="step-info">
                Current action: Initializing tree generation...
            </div>
            
            <canvas id="treeCanvas" width="800" height="500"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
    </div>

    <script>
        // Animation control variables
        let animationSpeed = 1000; // ms per step
        let animationPaused = true;
        let animationInterval;
        
        // GP variables
        const TERMINALS = ['x', 'y', '1', '0', 'rand'];
        const FUNCTIONS = ['+', '-', '*', '/', 'sin', 'cos', 'sqrt'];
        const FUNCTION_ARITIES = {'+': 2, '-': 2, '*': 2, '/': 2, 'sin': 1, 'cos': 1, 'sqrt': 1};
        const MAX_DEPTH = 3;
        
        // Canvas setup
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const NODE_RADIUS = 20;
        
        // Animation state
        let currentMethod = 'grow'; // Start with grow method
        let treeRoot = null;
        let currentNode = null;
        let executionStack = [];
        let nodeSequence = [];
        let currentSelection = null;
        
        // UI elements
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speedSlider');
        const methodDisplay = document.getElementById('method-display');
        const terminalsContainer = document.getElementById('terminals-container');
        const functionsContainer = document.getElementById('functions-container');
        const selectionInfo = document.getElementById('selection-info');
        const stepInfo = document.getElementById('step-info');
        const tooltip = document.getElementById('tooltip');
        
        // Create node set displays
        function createNodeSetDisplays() {
            // Create terminal nodes
            terminalsContainer.innerHTML = '';
            for (let terminal of TERMINALS) {
                const nodeElem = document.createElement('div');
                nodeElem.className = 'node-item terminal-node';
                nodeElem.textContent = terminal;
                nodeElem.dataset.value = terminal;
                terminalsContainer.appendChild(nodeElem);
                
                // Add tooltip for 'rand'
                if (terminal === 'rand') {
                    nodeElem.addEventListener('mouseover', (e) => {
                        tooltip.style.display = 'block';
                        tooltip.style.left = (e.pageX + 10) + 'px';
                        tooltip.style.top = (e.pageY + 10) + 'px';
                        tooltip.textContent = 'Random constant between -1 and 1';
                    });
                    nodeElem.addEventListener('mouseout', () => {
                        tooltip.style.display = 'none';
                    });
                }
            }
            
            // Create function nodes
            functionsContainer.innerHTML = '';
            for (let func of FUNCTIONS) {
                const nodeElem = document.createElement('div');
                nodeElem.className = 'node-item function-node';
                nodeElem.textContent = func;
                nodeElem.dataset.value = func;
                functionsContainer.appendChild(nodeElem);
                
                // Add tooltip with arity info
                nodeElem.addEventListener('mouseover', (e) => {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.pageX + 10) + 'px';
                    tooltip.style.top = (e.pageY + 10) + 'px';
                    tooltip.textContent = `Arity: ${FUNCTION_ARITIES[func]}`;
                });
                nodeElem.addEventListener('mouseout', () => {
                    tooltip.style.display = 'none';
                });
            }
        }
        
        // Update node set highlighting
        function updateNodeHighlighting() {
            // Remove all highlighting
            document.querySelectorAll('.node-item').forEach(node => {
                node.classList.remove('selected');
            });
            
            // Add highlighting to current selection
            if (currentSelection) {
                document.querySelectorAll(`.node-item[data-value="${currentSelection}"]`).forEach(node => {
                    node.classList.add('selected');
                });
                
                // Update selection info
                if (FUNCTIONS.includes(currentSelection)) {
                    selectionInfo.textContent = `Selected: ${currentSelection} (Function with arity ${FUNCTION_ARITIES[currentSelection]})`;
                    selectionInfo.style.color = '#3498db';
                } else {
                    selectionInfo.textContent = `Selected: ${currentSelection} (Terminal)`;
                    selectionInfo.style.color = '#2ecc71';
                }
            } else {
                selectionInfo.textContent = '';
            }
        }
        
        // Initialize execution sequence
        function initializeExecution() {
            // Reset all state
            treeRoot = null;
            currentNode = null;
            executionStack = [];
            nodeSequence = [];
            currentSelection = null;
            
            // Update method display
            methodDisplay.textContent = `Method: ${currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)}`;
            stepInfo.textContent = "Starting tree generation with the " + currentMethod + " method...";
            
            // Start with the first call to halfAndHalf
            executionStack.push({
                func: 'halfAndHalf',
                step: 'initialize',
                args: { maxDepth: MAX_DEPTH },
                context: {},
                returnTo: null
            });
        }
        
        // Execute a single step of the animation
        function executeStep() {
            if (executionStack.length === 0) {
                stopAnimation();
                stepInfo.textContent = "Tree generation complete!";
                return;
            }
            
            // Get the current frame from the stack
            const currentFrame = executionStack[executionStack.length - 1];
            
            // Execute actions based on the current function
            switch (currentFrame.func) {
                case 'halfAndHalf':
                    executeHalfAndHalf(currentFrame);
                    break;
                case 'generateTree':
                    executeGenerateTree(currentFrame);
                    break;
            }
            
            // Update visualization
            updateNodeHighlighting();
            updateTreeVisualization();
        }
        
        // Execute steps in halfAndHalf function
        function executeHalfAndHalf(frame) {
            switch(frame.step) {
                case 'initialize':
                    frame.context.method = currentMethod;
                    frame.step = 'call-generate';
                    stepInfo.textContent = "Initializing tree generation with " + currentMethod + " method";
                    break;
                case 'call-generate':
                    executionStack.push({
                        func: 'generateTree',
                        step: 'initialize',
                        args: { 
                            depth: 0, 
                            maxDepth: frame.args.maxDepth, 
                            method: frame.context.method 
                        },
                        context: {},
                        returnTo: { func: 'halfAndHalf', step: 'return' }
                    });
                    stepInfo.textContent = "Creating root node at depth 0";
                    break;
                case 'return':
                    treeRoot = frame.returnValue;
                    executionStack.pop(); // Remove this frame
                    stepInfo.textContent = "Tree construction complete!";
                    break;
            }
        }
        
        // Execute steps in generateTree function
        function executeGenerateTree(frame) {
            const { depth, maxDepth, method } = frame.args;
            
            switch(frame.step) {
                case 'initialize':
                    frame.context.node = {};
                    frame.step = 'check-depth';
                    stepInfo.textContent = `Creating new node at depth ${depth}/${maxDepth}`;
                    break;
                case 'check-depth':
                    if (depth === maxDepth) {
                        frame.step = 'terminal-selection';
                        stepInfo.textContent = `Max depth ${maxDepth} reached, selecting terminal node`;
                    } else {
                        frame.step = 'method-check';
                        stepInfo.textContent = `Depth ${depth} < max depth ${maxDepth}, checking method: ${method}`;
                    }
                    break;
                case 'terminal-selection':
                    currentSelection = randomSelect(TERMINALS);
                    frame.context.terminal = currentSelection;
                    frame.step = 'create-terminal';
                    stepInfo.textContent = `Selected terminal: ${currentSelection}`;
                    break;
                case 'create-terminal':
                    frame.context.node.type = 'terminal';
                    frame.context.node.value = frame.context.terminal;
                    currentNode = frame.context.node;
                    nodeSequence.push(currentNode);
                    frame.step = 'return-terminal';
                    stepInfo.textContent = `Created terminal node: ${currentSelection}`;
                    break;
                case 'return-terminal':
                    frame.returnValue = frame.context.node;
                    executionStack.pop();
                    stepInfo.textContent = `Returning terminal node: ${frame.context.node.value}`;
                    
                    // Handle return to parent frame
                    if (frame.returnTo) {
                        const parentFrame = executionStack[executionStack.length - 1];
                        parentFrame.step = frame.returnTo.step;
                        parentFrame.returnValue = frame.returnValue;
                    }
                    break;
                case 'method-check':
                    if (method === 'full') {
                        frame.step = 'full-method';
                        stepInfo.textContent = "Using 'full' method - selecting function node";
                    } else {
                        frame.step = 'grow-method';
                        stepInfo.textContent = "Using 'grow' method - selecting from terminals and functions";
                    }
                    break;
                case 'full-method':
                    currentSelection = randomSelect(FUNCTIONS);
                    frame.context.func = currentSelection;
                    frame.context.node.type = 'function';
                    frame.context.node.value = currentSelection;
                    currentNode = frame.context.node;
                    nodeSequence.push(currentNode);
                    frame.step = 'add-children';
                    stepInfo.textContent = `Selected function: ${currentSelection}`;
                    break;
                case 'grow-method':
                    frame.context.allNodes = [...TERMINALS, ...FUNCTIONS];
                    currentSelection = randomSelect(frame.context.allNodes);
                    frame.context.selection = currentSelection;
                    
                    if (FUNCTIONS.includes(currentSelection)) {
                        frame.step = 'grow-function';
                        stepInfo.textContent = `Selected function: ${currentSelection}`;
                    } else {
                        frame.step = 'grow-terminal';
                        stepInfo.textContent = `Selected terminal: ${currentSelection}`;
                    }
                    break;
                case 'grow-function':
                    frame.context.node.type = 'function';
                    frame.context.node.value = frame.context.selection;
                    currentNode = frame.context.node;
                    nodeSequence.push(currentNode);
                    frame.step = 'add-children';
                    break;
                case 'grow-terminal':
                    frame.context.node.type = 'terminal';
                    frame.context.node.value = frame.context.selection;
                    currentNode = frame.context.node;
                    nodeSequence.push(currentNode);
                    frame.step = 'return-terminal';
                    break;
                case 'add-children':
                    frame.context.node.children = [];
                    frame.context.arity = getArity(frame.context.node.value);
                    frame.context.i = 0;
                    frame.step = 'loop-check';
                    stepInfo.textContent = `Adding ${frame.context.arity} children to function ${frame.context.node.value}`;
                    break;
                case 'loop-check':
                    if (frame.context.i < frame.context.arity) {
                        frame.step = 'generate-child';
                        stepInfo.textContent = `Generating child ${frame.context.i+1}/${frame.context.arity} for ${frame.context.node.value}`;
                    } else {
                        frame.step = 'return-function';
                        stepInfo.textContent = `All children added to ${frame.context.node.value}, returning function node`;
                    }
                    break;
                case 'generate-child':
                    executionStack.push({
                        func: 'generateTree',
                        step: 'initialize',
                        args: { depth: depth + 1, maxDepth, method },
                        context: {},
                        returnTo: { func: 'generateTree', step: 'add-child' }
                    });
                    break;
                case 'add-child':
                    frame.context.node.children.push(frame.returnValue);
                    frame.context.i++;
                    frame.step = 'loop-check';
                    stepInfo.textContent = `Added child ${frame.context.i}/${frame.context.arity} to ${frame.context.node.value}`;
                    break;
                case 'return-function':
                    frame.returnValue = frame.context.node;
                    executionStack.pop();
                    stepInfo.textContent = `Returning function node: ${frame.context.node.value} with ${frame.context.node.children.length} children`;
                    
                    // Handle return to parent frame
                    if (frame.returnTo) {
                        const parentFrame = executionStack[executionStack.length - 1];
                        parentFrame.step = frame.returnTo.step;
                        parentFrame.returnValue = frame.returnValue;
                    }
                    break;
            }
        }
        
        // Random selection helper
        function randomSelect(array) {
            return array[Math.floor(Math.random() * array.length)];
        }
        
        // Get arity for a function
        function getArity(funcName) {
            return FUNCTION_ARITIES[funcName] || 0;
        }
        
        // Update tree visualization
        function updateTreeVisualization() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!treeRoot && nodeSequence.length > 0) {
                // Tree is still being constructed
                visualizePartialTree();
            } else if (treeRoot) {
                // Tree is complete
                assignTreePositions(treeRoot, canvas.width / 2, 50, 160, 80);
                visualizeTree(treeRoot);
            }
        }
        
        // Visualize partial tree during construction
        function visualizePartialTree() {
            // Build the tree structure from the node sequence
            let nodeMap = new Map(); // Maps nodes to their parent-child relationships
            
            for (let node of nodeSequence) {
                if (!nodeMap.has(node)) {
                    nodeMap.set(node, {
                        parent: null,
                        childIndex: -1
                    });
                }
            }
            
            // Establish parent-child relationships
            for (let node of nodeSequence) {
                if (node.children) {
                    for (let i = 0; i < node.children.length; i++) {
                        let child = node.children[i];
                        if (nodeMap.has(child)) {
                            nodeMap.get(child).parent = node;
                            nodeMap.get(child).childIndex = i;
                        }
                    }
                }
            }
            
            // Find roots (nodes without parents)
            let roots = [];
            for (let [node, info] of nodeMap.entries()) {
                if (!info.parent) {
                    roots.push(node);
                }
            }
            
            // Position root nodes
            let rootSpacing = canvas.width / (roots.length + 1);
            for (let i = 0; i < roots.length; i++) {
                let root = roots[i];
                assignPartialTreePositions(root, (i + 1) * rootSpacing, 50, 140, 80);
            }
            
            // Draw all connections first
            for (let node of nodeSequence) {
                if (node.children) {
                    for (let child of node.children) {
                        if (child.x !== undefined) { // Only draw if the child has been positioned
                            drawConnection(node, child);
                        }
                    }
                }
            }
            
            // Then draw all nodes
            for (let node of nodeSequence) {
                if (node.x !== undefined) { // Only draw if the node has been positioned
                    drawNode(node, node === currentNode);
                }
            }
            
            // Draw connections being built (from execution stack)
            drawInProgressConnections();
        }
        
        // Draw connections that are currently being built
        function drawInProgressConnections() {
            if (executionStack.length > 1) {
                for (let i = executionStack.length - 2; i >= 0; i--) {
                    const frame = executionStack[i];
                    
                    // Check if this frame is adding a child to a parent
                    if (frame.func === 'generateTree' && 
                        frame.step === 'generate-child' &&
                        frame.context.node &&
                        frame.context.node.children) {
                        
                        // The parent node is being built - find the current child node position
                        const parentNode = frame.context.node;
                        const currentChildIndex = frame.context.i;
                        
                        if (parentNode.x !== undefined && 
                            currentChildIndex !== undefined && 
                            currentNode && 
                            currentNode.x !== undefined) {
                            
                            // Draw a dashed line to the current node being constructed
                            ctx.save();
                            ctx.setLineDash([5, 3]);
                            ctx.strokeStyle = '#999';
                            ctx.beginPath();
                            ctx.moveTo(parentNode.x, parentNode.y + NODE_RADIUS);
                            ctx.lineTo(currentNode.x, currentNode.y - NODE_RADIUS);
                            ctx.stroke();
                            ctx.restore();
                        }
                        
                        break;
                    }
                }
            }
        }
        
        // Assign positions to nodes in a partial tree
        function assignPartialTreePositions(node, x, y, dx, dy) {
            node.x = x;
            node.y = y;
            
            if (node.children && node.children.length > 0) {
                if (node.children.length === 1) {
                    // Center the only child
                    assignPartialTreePositions(node.children[0], x, y + dy, dx / 2, dy);
                } else {
                    // Calculate width needed for children
                    let totalWidth = dx * (node.children.length - 1);
                    let startX = x - totalWidth / 2;
                    
                    for (let i = 0; i < node.children.length; i++) {
                        let childX = startX + i * dx;
                        assignPartialTreePositions(node.children[i], childX, y + dy, dx / 2, dy);
                    }
                }
            }
        }
        
        // Draw a node
        function drawNode(node, isHighlighted = false) {
            ctx.save();
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
            
            if (node.type === 'function') {
                ctx.fillStyle = isHighlighted ? '#3498db' : 'white';
                ctx.strokeStyle = '#3498db';
            } else { // terminal
                ctx.fillStyle = isHighlighted ? '#2ecc71' : 'white';
                ctx.strokeStyle = '#2ecc71';
            }
            
            ctx.lineWidth = isHighlighted ? 3 : 2;
            ctx.fill();
            ctx.stroke();
            
            // Draw label
            ctx.fillStyle = isHighlighted ? 'white' : (node.type === 'function' ? '#3498db' : '#2ecc71');
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, node.x, node.y);
            
            ctx.restore();
        }
        
        // Draw a connection between two nodes
        function drawConnection(parent, child) {
            ctx.beginPath();
            ctx.moveTo(parent.x, parent.y + NODE_RADIUS);
            ctx.lineTo(child.x, child.y - NODE_RADIUS);
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Assign positions to tree nodes for visualization
        function assignTreePositions(node, x, y, dx, dy) {
            node.x = x;
            node.y = y;
            
            if (node.children && node.children.length > 0) {
                if (node.children.length === 1) {
                    // Center the only child
                    assignTreePositions(node.children[0], x, y + dy, dx / 2, dy);
                } else {
                    // Calculate width needed for children
                    let totalWidth = dx * (node.children.length - 1);
                    let startX = x - totalWidth / 2;
                    
                    for (let i = 0; i < node.children.length; i++) {
                        let childX = startX + i * dx;
                        assignTreePositions(node.children[i], childX, y + dy, dx / 2, dy);
                    }
                }
            }
        }
        
        // Visualize the complete tree
        function visualizeTree(node) {
            // Draw connections to children first (so they're behind nodes)
            if (node.children) {
                for (let child of node.children) {
                    drawConnection(node, child);
                    visualizeTree(child);
                }
            }
            
            // Draw the node itself
            drawNode(node, node === currentNode);
        }
        
        // Animation control functions
        function startAnimation() {
            if (!animationInterval) {
                animationPaused = false;
                startBtn.textContent = 'Restart';
                animationInterval = setInterval(() => {
                    if (!animationPaused) {
                        executeStep();
                    }
                }, animationSpeed);
            } else {
                // Restart animation
                stopAnimation();
                resetAnimation();
                startAnimation();
            }
        }
        
        function pauseAnimation() {
            animationPaused = true;
        }
        
        function stopAnimation() {
            clearInterval(animationInterval);
            animationInterval = null;
            animationPaused = true;
        }
        
        function resetAnimation() {
            stopAnimation();
            startBtn.textContent = 'Start Animation';
            initializeExecution();
            updateNodeHighlighting();
            updateTreeVisualization();
        }
        
        function nextStep() {
            pauseAnimation();
            executeStep();
        }
        
        // Set up event listeners
        startBtn.addEventListener('click', startAnimation);
        pauseBtn.addEventListener('click', pauseAnimation);
        nextBtn.addEventListener('click', nextStep);
        resetBtn.addEventListener('click', resetAnimation);
        
        speedSlider.addEventListener('input', () => {
            animationSpeed = 2100 - speedSlider.value; // Invert so higher = faster
            if (animationInterval) {
                stopAnimation();
                startAnimation();
            }
        });
        
        // Toggle between grow and full methods
        document.addEventListener('keydown', (e) => {
            if (e.key === 'g' || e.key === 'G') {
                currentMethod = 'grow';
                resetAnimation();
            } else if (e.key === 'f' || e.key === 'F') {
                currentMethod = 'full';
                resetAnimation();
            }
        });
        
        // Initialize
        createNodeSetDisplays();
        resetAnimation();
    </script>
</body>
</html>